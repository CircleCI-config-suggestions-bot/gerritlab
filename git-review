#!/usr/bin/env python

import sys
import os
import re
import argparse
import collections
import json
from git import Repo
import requests

from bcolors import bcolors

url = None
headers = None
change_id_re = r"Change-Id: (.+?)(\s|$)"
dry_run = False


def load_gitlab_config(root_dir):
    global url
    global headers
    with open(os.path.join(root_dir, ".git/hooks/gitlab_config.json")) as f:
        gitlab_config = json.load(f)
    url = "{}/projects/{}/merge_requests".format(
        gitlab_config["GITLAB_API_V4"], gitlab_config["PROJECT_ID"])
    headers = {"PRIVATE-TOKEN": gitlab_config["PRIVATE_TOKEN"]}


def get_msg_title_description(msg):
    title, desc = tuple(msg.split("\n", 1))
    desc = re.sub(change_id_re, "", desc)
    return title, desc


def get_change_id(msg):
    m = re.search(change_id_re, msg)
    if m:
        return m.group(1)
    else:
        raise ValueError("Didn't find the Change-Id in the commit message!")


def get_remote_branch_name(local_branch, change_id):
    return "{}-{}".format(local_branch, change_id[1:5])


def is_remote_stale(commits, remote_commits):
    """Checks if remote becomes stale due to local changes."""
    shas = set([c.hexsha for c in commits])
    remote_shas = set([c.hexsha for c in remote_commits])
    return shas != remote_shas


def get_merge_request(branch):
    """Return a `MergeRequest` given branch name."""
    r = requests.get("{}?state=opened".format(url), headers=headers)
    for mr in r.json():
        if mr["source_branch"] == branch:
            return MergeRequest(json_data = mr)
    return None


def submit_merge_requests(local_branch):
    """Submits merge requests."""
    # Get MRs created off of the given branch.
    r = requests.get("{}?state=opened".format(url), headers=headers)
    mrs = collections.OrderedDict()
    for mr in r.json():
        if mr["source_branch"].startswith(local_branch):
            mrs[mr["target_branch"]] = mr
    if len(mrs) == 0:
        print("No MRs found for this branch: {}".format(local_branch))
        return

    def mergeable(mr):
        return mr["mergeable"] == True

    def find_mergeable_chain(mrs, root):
        if not mergeable(root):
            return []
        else:
            mergeables = [MergeRequest(json_data=root)]
            if root["source_branch"] not in mrs:
                return mergeables
            else:
                next_mr = mrs[root["source_branch"]]
                mergeables.extend(find_mergeable_chain(mrs, next_mr))
                return mergeables

    root = mrs["master"]
    mergeables = find_mergeable_chain(mrs, root)
    if len(mergeables) == 0:
        print("No MRs are currently mergeable.")
        return

    # We must submit MRs from the oldest. And before submitting an MR, we must
    # change its target_branch to master.
    for mr in mergeables:
        if not dry_run:
            mr.update(target_branch="master")
            #FIXME: Poll the merge req status and waiting until merge_status is
            # no longer "checking".
            mr.submit()

    print()
    print(bcolors.OKGREEN + "SUCCESS" + bcolors.ENDC)
    print()
    print("{} MRs submitted at {}:".format(len(mrs), remote.url))
    for mr in mergeables:
        mr.print_info()


def create_merge_requests(repo, remote, local_branch):
    """Creates new merge requests on remote."""

    def delete_invalid_merge_requests(commits):
        """Deletes the invalid merge requests and their branches."""
        # Get the remote commits that are ahead of the origin/master.
        remote_commits = list(
            repo.iter_commits("origin/master..origin/{}".format(local_branch)))
        remote_commits.reverse()

        change_ids = set([get_change_id(c.message) for c in commits])
        remote_change_ids = set(
            [get_change_id(c.message) for c in remote_commits])
        deleted_change_ids = list(remote_change_ids - change_ids)
        for change_id in deleted_change_ids:
            # Delete the MR by its iid.
            mr = get_merge_request(
                get_remote_branch_name(local_branch, change_id))
            mr.delete()
            # Delete the branch as well.
            remote.push(
                refspec=":{}".format(
                    get_remote_branch_name(local_branch, change_id)))

    # Get the local commits that are ahead of the origin/master.
    remote.fetch(prune=True)
    commits = list(repo.iter_commits("origin/master..{}".format(local_branch)))
    commits.reverse()

    # Delete the MRs whose commits are now deleted since the last review.
    if "origin/{}".format(local_branch) in [r.name for r in repo.references]:
        delete_invalid_merge_requests(commits)

    # Push the commits to remote by creating a new branch for each.
    remote.push(
        refspec="{}:refs/heads/{}".format(local_branch, local_branch),
        force=True)
    remote_branches = {}
    for c in commits:
        change_id = get_change_id(c.message)
        remote_branch = get_remote_branch_name(local_branch, change_id)
        remote.push(
            refspec="{}:refs/heads/{}".format(c.hexsha, remote_branch),
            force=True)
        remote_branches[c.hexsha] = remote_branch

    # Create a merge request for each commit.
    mrs = []
    for idx, c in enumerate(commits):
        change_id = get_change_id(c.message)
        source_branch = remote_branches[c.hexsha]
        if idx == 0:
            # If this is the oldest commit, then the target branch should be
            # master.
            target_branch = "master"
        else:
            target_branch = remote_branches[commits[idx - 1].hexsha]
        title, desp = get_msg_title_description(c.message)
        mr = get_merge_request(source_branch)
        if mr is not None:
            mr.update(
                source_branch=source_branch, target_branch=target_branch,
                title=title, description=desp)
        else:
            mr = MergeRequest(
                source_branch=source_branch, target_branch=target_branch,
                title=title, description=desp)
            mr.create()
        mrs.append(mr)
    print()
    print(bcolors.OKGREEN + "SUCCESS" + bcolors.ENDC)
    print()
    print("{} new MRs to {}:".format(len(mrs), remote.url))
    for mr in mrs:
        mr.print_info()


class MergeRequest:

    def __init__(
            self, source_branch=None, target_branch=None,
            title=None, description=None, json_data=None):
        self._source_branch = source_branch if source_branch else json_data[
            "source_branch"]
        self._target_branch = target_branch if target_branch else json_data[
            "target_branch"]
        self._local_branch = self._source_branch.rsplit("-", 1)[0]
        self._title = title if title else json_data["title"]
        self._description = description if description else json_data[
            "description"]
        self._iid = json_data["iid"] if json_data else None
        self._mr_url = json_data["web_url"] if json_data else None

    def print_info(self):
        print("* {}".format(self._title))
        print("    MR link: {}".format(self._mr_url))
        print(
            "    {} -> {} ({})".format(
                self._local_branch, self._source_branch, self._target_branch))

    def create(self):
        data = {
            "source_branch": self._source_branch,
            "target_branch": self._target_branch,
            "title": self._title,
            "description": self._description,
        }
        r = requests.post(url, headers=headers, data=data)
        if r.status_code != requests.codes.ok:
            r.raise_for_status()
        data = r.json()
        self._iid = data["iid"]
        self._mr_url = data["web_url"]

    def update(
            self, source_branch=None, target_branch=None, title=None,
            description=None):
        if source_branch is not None:
            self._source_branch = source_branch
        if target_branch is not None:
            self._target_branch = target_branch
        if title is not None:
            self._title = title
        if description is not None:
            self._description = description
        data = {
            "source_branch": self._source_branch,
            "target_branch": self._target_branch,
            "title": self._title,
            "description": self._description,
        }
        r = requests.put(
            "{}/{}".format(url, self._iid), headers=headers, data=data)
        if r.status_code != requests.codes.ok:
            r.raise_for_status()
        data = r.json()
        self._iid = data["iid"]
        self._mr_url = data["web_url"]

    def submit(self):
        if self._iid is None:
            raise ValueError("Must set iid before submittng an MR!")
        r = requests.put("{}/{}/merge".format(url, self._iid), headers=headers)
        if r.status_code != requests.codes.ok:
            r.raise_for_status()

    def delete(self):
        if self._iid is None:
            raise ValueError("Must set iid before deleting an MR!")
        r = requests.delete("{}/{}".format(url, self._iid), headers=headers)
        if r.status_code != requests.codes.ok:
            r.raise_for_status()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "remote", type=str, help="The remote to push the reviews.")
    parser.add_argument(
        "local_branch", type=str, nargs="?",
        help="The local branch to be reviewed.")
    parser.add_argument(
        "--merge", "-m", action="store_true", default=False,
        help="Merge the MRs if they are approved.")
    parser.add_argument(
        "--dry-run", "-d", action="store_true", default=False,
        help="Dry run the command.")
    args = parser.parse_args()

    repo = Repo(os.getcwd(), search_parent_directories=True)
    load_gitlab_config(repo.git.rev_parse("--show-toplevel"))
    local_branch = args.local_branch
    if args.local_branch is None:
        local_branch = repo.active_branch.name
        print(
            bcolors.WARNING + "warning" + bcolors.ENDC +
            ": No local branch specified. Using the active branch: {}".format(
                local_branch))

    global dry_run
    dry_run = args.dry_run
    if dry_run:
        print(
            bcolors.WARNING + "warning" + bcolors.ENDC + ": Dry running mode.")

    # Submit the MRs if they become mergeable.
    if args.merge:
        print("Submitting merge requests:")
        submit_merge_requests(local_branch)
        sys.exit(0)

    remote = repo.remote(name=args.remote)
    create_merge_requests(repo, remote, local_branch)


if __name__ == "__main__":
    main()
